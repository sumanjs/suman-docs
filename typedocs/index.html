<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>The SumanJS Documentation</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">The SumanJS Documentation</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> The SumanJS Documentation</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><img align="right" width="75%" height="75%" src="https://raw.githubusercontent.com/sumanjs/suman-docs/master/images/suman.png"></p>
				<p><a href="https://badge.fury.io/js/suman"><img src="https://badge.fury.io/js/suman.svg" alt="npm version"></a></p>
				<p><a href="https://greenkeeper.io/"><img src="https://badges.greenkeeper.io/sumanjs/suman.svg" alt="Greenkeeper badge"></a></p>
				<p><a href="https://travis-ci.org/ORESoftware/suman"><img src="https://travis-ci.org/ORESoftware/suman.svg?branch=master" alt="Build Status"></a></p>
				<p><a href="https://coveralls.io/github/ORESoftware/suman?branch=master"><img src="https://coveralls.io/repos/github/ORESoftware/suman/badge.svg?branch=master" alt="Coverage Status"></a></p>
				<p><img align="right" width="50%" height="50%" src="https://raw.githubusercontent.com/sumanjs/suman-docs/master/images/suman-hex.png"></p>
				<h1 id="suman-universal-test-runner-primarily-for-node-js-and-front-end-javascript">Suman: universal test runner, primarily for Node.js and front-end JavaScript</h1>
				<p>Designed to run tests written in any language - because Suman can runs tests as child processes - just write TAP to stdout
					via the runtime of choice. Intended to work with Selenium, in the browser,
				and to do large-scale backend system and integration testing.  </p>
				<p>Suman is made up of two independent pieces:</p>
				<ol>
					<li>A CLI that can run a test in any language, and is designed to handle transpilation/compilation.</li>
					<li>A test harness that can be used with JavaScript/Node.js tests</li>
				</ol>
				<p>
					## If your team is interested in speeding up your testing cycles, Suman is the absolute right place to look for answers.
					## Suman is designed to be &#39;better all-around&#39; than AVA, TapJS and Mocha, etc. If there were no room for improvement, Suman would never have been written in the first place.
					---
					## Quick feature list:
					<p>
						<div> ✓ <b style="color:purple">  fully asynchronous </b> =&gt; allows for easy, dynamic test case creation
							<div> ✓ <b style="color:purple">  agnostic </b> =&gt; works with your favorite assertion library
								<div> ✓ <b style="color:purple">  agnostic </b> =&gt; want to learn a new language? write a test script with language X, then run the test with Suman.<em>
										<div> ✓ <b style="color:purple">  no globals </b> =&gt;  no global variables as part of test harness - therefore JS tests can be run with Node.js executable </div>
										<div> ✓ <b style="color:purple">  flexible, generic, robust </b> =&gt;  CLI can run JS tests directly, or in a child process </div>
										<div> ✓ <b style="color:purple">  flexible, generic, robust </b> =&gt;  Composability =&gt; Suman tests can run other Suman tests (in child processes), etc, etc. </div>
										<div> ✓ <b style="color:purple">  test isolation </b> =&gt;  each test can run in its own process </div>
										<div> ✓ <b style="color:purple">  test independence </b> =&gt;  easily run only one test at a time (unlike other Node.js test runners...)</div>
										<div> ✓ <b style="color:purple">  declarative style </b> =&gt; declare (sync and async) dependencies for each test, and only load those</div>
										<div> ✓ <b style="color:purple">  &quot;nodeable test scripts&quot; </b> =&gt; run individual tests with the node.js executable</div>
										<div> ✓ <b style="color:purple">  supports unit testing in the browser </b> (tested on Chrome and Firefox)</div>
										<div> ✓ <b style="color:purple">  supports observables (RxJS5) </b> </div>
								<div> ✓ synchronous <b style="color:purple"></em>and<em></b> asynchronous reporters (!)</div>
								<div> ✓ <b style="color:purple"> tests run in parallel in separate processes </b> </div>
								<div> ✓ execute tests written in <b style="color:purple">any</b> language, use write TAP to stdout</div>
								<div> ✓ only <b style="color:purple">18mbs </b> on filesystem as npm install -D</div>
								<div> ✓ works with <b style="color:purple"> Selenium </b> (use selenium-webdriver, wd, or webdriver.io)</div>
								<div> ✓ Built-in watch features =&gt; Watch files, and run tests on changes </div>
								<div> ✓ Everything in Suman is parallelizable </div>
								<div> ✓ Complete control =&gt; You </em>can* run unit tests all in the same process for speed, as needed. </div>
					</p>
					<p>For more detailed feature explanations, see below.</p>
					<p>Quick list of problems with other test runners:</p>
					<div> x  By default, Mocha runs all tests in a single process which has a lot of problems, including running out memory</div>
					<div> x  AVA uses Babel transpilation for all tests which also increases memory consumption heavily.</div>
					<hr>
					<h1 id="-9658-complete-documentation">&#9658; Complete Documentation</h1>
					<blockquote>
						<p>  The Suman docs =&gt; <a href="http://sumanjs.org" title="Suman Docs">sumanjs.org</a>  </p>
					</blockquote>
					<hr>
					<h2 id="suman-is-a-singular-test-runner-focused-on-node-js-and-front-end-javascript-but-is-both-generic-and-robust-so-that-it-can-run-tests-in-any-runtime-or-language">Suman is a singular test runner focused on Node.js and front-end JavaScript, but is both generic and robust so that it can run tests in any runtime or language</h2>
					<p>Suman is written with Node.js, and is focused on testing Node.js code,
						but can run tests written in any language, not just JavaScript. This is
					because it can run tests in child processes and collect results using TAP (Test Anything Protocol, via stdout), IPC, or websockets.</p>
					<p>Suman can run a test in any language which exposes a script with a hashbang or a binary entrypoint file (e.g. Golang or C).
						To run Java tests, where Java does not compile to binary and where you cannot put a hashbang in a .class file,
					you would need to call Java from a shell script.</p>
					<p>It is designed for maximum test performance, via careful parallelization at
					every juncture in the testing process/pipeline. </p>
					<h1 id="a-simple-relationship-">A simple relationship:</h1>
					<h2 id="suman-ava-mocha-lab-">Suman = ( AVA + Mocha + Lab )</h2>
					<hr>
					<p>To use Suman, you need the following ingredients:</p>
					<ul>
						<li>npm</li>
						<li>bash</li>
						<li>SQLite3</li>
						<li>node.js</li>
						<li>readlink</li>
					</ul>
					<p>If you are on MacOS or Linux, you have those, so you&#39;re good.</p>
					<hr>
					<h3 id="-9658-disclaimers-">&#9658; Disclaimers:</h3>
					<p>&gt;</p>
					<blockquote>
						<p>Suman supports Node versions &gt;= 4.0.0.</p>
						<p>Windows support is on the roadmap, but will not be ready anytime soon. Currently, MacOS and *nix support only.</p>
					</blockquote>
					<hr>
					<h1 id="-9658-installation">&#9658; Installation</h1>
					<p><i> For command line tools:</i></p>
					<h2 id="-npm-install-g-suman-"><code>$ npm install -g suman</code></h2>
					<p>=&gt; <strong>Please</strong> do <em>not</em> use sudo to install suman globally; if you need to use sudo, then something is probably wrong
						=&gt; See: <a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a>
					=&gt; To avoid any problems with permissions, Suman recommends usage of NVM</p>
					<p><i> For test suites in your project:</i></p>
					<h2 id="-cd-project-root-suman-init-"><code>$ cd &lt;project-root&gt; &amp;&amp; suman --init</code></h2>
					<ul>
						<li>To avoid global NPM modules see: &quot;Local installations only&quot;</li>
					</ul>
					<p>=&gt; to convert a Mocha test or whole directory(s) of Mocha tests to Suman tests use <br></p>
					<h3 id="-suman-convert-src-src-file-src-dir-dest-dest-dir-"><code>$ suman --convert --src=&lt;src-file/src-dir&gt; --dest=&lt;dest-dir&gt;</code></h3>
					<p>=&gt; to simply install Suman as dev-dependency in any project you can use <code>$ npm install -D suman</code>, <br>
						however <code>$ suman --init</code> is the much preferred way to initialized suman in a given project, because it will
					add a directory to your project which you can move to a location of your choosing.</p>
					<h3 id="-9658-local-installations-only-">&#9658; Local installations only =&gt;</h3>
					<p>If you wish to avoid global NPM module installations, we commend you, see:
					<a href="http://sumanjs.org/tutorial-11-advanced-installation.html" title="Suman Docs: Advanced Installation">http://sumanjs.org/tutorial-11-advanced-installation.html/</a> </p>
					<h2 id="example-commands">Example commands</h2>
					<pre><code class="lang-bash">
 suman --runner <span class="hljs-built_in">test</span>/**/*.py   <span class="hljs-comment"># run python tests</span>
 suman --runner <span class="hljs-built_in">test</span>/**/*.rb   <span class="hljs-comment"># run ruby tests</span>
 suman --runner <span class="hljs-built_in">test</span>/**/*.sh  <span class="hljs-built_in">test</span>/**/*.go  <span class="hljs-comment"># run bash and golang tests</span>

 suman <span class="hljs-built_in">test</span>/src/*.spec.js --concurrency=6 <span class="hljs-comment"># run the matching tests, no more than 6 Node.js processes at a time.</span>

 suman -w project   <span class="hljs-comment"># run a set of tests when a project file changes</span>

 suman -w tests   <span class="hljs-comment"># when developing a test, run it upon changes</span>
</code></pre>
					<h2 id="the-suman-story">The Suman Story</h2>
					<p>I started writing Suman in October 2015. After 6 months of working with Mocha, I started experiencing many of its shortcomings.
						Mocha has a handful of major problems and 100 minor ones. Frankly, Mocha is poorly designed software - the fact that it concatenates
						all your tests in a single process is simply not how testing should work; especially for a dynamic language where the global
						scope can be easily polluted by inexperienced developers. Once you start writing non-trivial tests with Mocha, it becomes
					very difficult to debug tests and run only one test at a time. </p>
					<p>About 2 weeks after I started writing Suman, I discovered AVA. AVA is much better than Mocha, but it &quot;forces&quot; you to use transpilation
						and heavily depends on its own assertion library for correct functionality. Meaning - you can&#39;t use the assertion library that you already familiar with.
						It&#39;s also missing some nice features from Mocha, including nested blocks. So I decided to continue working on Suman, and essentially take the best from Mocha and AVA,
						and also borrow the best ideas from TapJS/Tape and Lab (Lab is the test runner for the Hapi framework.). I have spent a lot of time
					on the issue trackers on basically every Node.js testing framework.</p>
					<p>Just like AVA, Suman runs tests in child processes. With Suman, you can also run any single test with just the node executable,
						something that you cannot do with AVA. A big hangup for me. Beyond the standard advantages of speed, isolation and independence, running tests
						in child processes has one other major advantage: The Suman test runner is capable of running tests in any language. While the Suman runner
						communicates with Node.js child processes through the standard IPC channel,
					it can also parse TAP output from a child process running in any language.</p>
					<p>Suman is setup to run Node.js tests, and any test in any language that writes TAP to stdout. This is pretty awesome.</p>
					<p>Support for transpilation is also first rate - Suman supports generic transpilation/compilation for any language.
						The configuration to support transpilation is the same, no matter what language you are looking to transpile/compile.
					Over time, better and better support for incremental transpilation/compilation will be created.</p>
					<h3 id="suman-uses-several-intelligent-pieces-of-setup-">Suman uses several intelligent pieces of setup:</h3>
					<p>Global installations of Suman simply look for local installations to run. So if you run the suman command installed via npm install -g suman, that CLI
						will just invoke the local installation of suman in any given project - this prevents any potential
					conflicts if there is a difference between the global/local module versions. Excellent!</p>
					<p>If you use NVM and switch between Node.js versions, you can use bash functions (provided by SumanJS) which will
					denecessitate the need for any global installations of Suman at all.</p>
					<p>Suman is designed to interop well with the most common libraries in the ecosystem for handling asynchronous code.</p>
					<h2 id="simple-example">Simple example</h2>
					<pre><code class="lang-js">
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> suman <span class="hljs-keyword">from</span> <span class="hljs-string">'suman'</span>;
<span class="hljs-keyword">const</span> Test = suman.init(<span class="hljs-built_in">module</span>)

Test.create(<span class="hljs-string">'example'</span>, (baz, assert, http, beforeEach, describe, inject, foo) =&gt; {  

    <span class="hljs-comment">// Suman uses simple old-school style JavaScript DI</span>
    <span class="hljs-comment">// we have injected some core modules by name (http, assert, path) </span>
    <span class="hljs-comment">// we have also injected a module from our own project, baz</span>

     inject(<span class="hljs-string">'bar'</span>, () =&gt; {
         <span class="hljs-keyword">return</span> baz(foo).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> v.filter(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.isGreen())
         })
     })

     beforeEach(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> {
         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this runs before each test'</span>)
     })

     describe(<span class="hljs-string">'foo'</span>, {<span class="hljs-attr">mode</span>:<span class="hljs-string">'series'</span>}, (bar, it, describe) =&gt; {

        it(<span class="hljs-string">'a'</span>, t =&gt; {
             assert.equal(t.title,<span class="hljs-string">'a'</span>)
        })

        it(<span class="hljs-string">'b'</span>, t =&gt; {
             assert.equal(t.title,<span class="hljs-string">'b'</span>) 
        })

        it(<span class="hljs-string">'c'</span>, t =&gt; {
             assert.equal(t.title,<span class="hljs-string">'c'</span>)           
        })

         describe(<span class="hljs-string">'nested child'</span>, {<span class="hljs-attr">mode</span>:<span class="hljs-string">'parallel'</span>}, (bar, it) =&gt; {

                it(<span class="hljs-string">'a'</span>, t =&gt; {
                     assert.equal(t.title,<span class="hljs-string">'a'</span>)
                })

                it(<span class="hljs-string">'b'</span>, t =&gt; {
                     assert.equal(t.title,<span class="hljs-string">'b'</span>) 
                })

                it(<span class="hljs-string">'c'</span>, t =&gt; {
                     assert.equal(t.title,<span class="hljs-string">'c'</span>)           
                })


             })


     })

})
</code></pre>
					<h1 id="-9658-purpose">&#9658; Purpose</h1>
					<p>The purpose of the Suman library is to provide the most sophisticated test runner in the Node.js ecosystem,
						with a better developer experience, better features, higher performance, improved debuggability,
						and more expressiveness than AVA, Mocha, and Tape.
						Suman is a first-rate library and we hope you take the time to compare its capabilities with AVA, Mocha, Tape, TapJS, etc.
						One of the more exciting things about Suman is that it can run tests written in any language; all you have to do
					is output TAP (Test Anything Protocol).</p>
					<p>The primary aims are:</p>
					<ul>
						<li>Developer experience and test debuggability are above ALL else</li>
						<li>Provide a beautiful and intuitive API</li>
						<li>Solve all major and minor problems in the Mocha API, specifically</li>
						<li>Borrow some of the best features from Mocha, AVA and Tape</li>
						<li>Make tests run faster by leveraging concurrency provided by async I/O <em>and</em> separate Node.js processes</li>
						<li><em>Isolate</em> tests by running them in separate processes, so they do not share memory nor interact directly</li>
						<li>Make tests <em>independent</em>, so that you can easily run one test at a time (damn you Mocha!).</li>
						<li>Make debugging your test files easier; this is achieved by allowing for the running of tests with the plain-old node executable,
						this makes Suman tests &quot;node-able&quot;</li>
						<li>Provide cleaner output, so that developer logging output is not necessarily mixed with test result =&gt;
						achieved by using child processes and ignoring stdout.</li>
						<li>Add the missing features from Mocha, Tape and AVA, while simplifying portions of the Mocha API and doing
						away with (implicit) global variables.</li>
						<li>Stick closely to the popular Mocha API, so that automatic conversion is possible from Mocha to Suman,
						and that transition is as seamless as possible for the developer - you do <em>not</em> have to learn a whole new API!</li>
						<li>Allow for maximum dynamicism so that Suman can match all use cases of users.</li>
						<li>Allow users to create Suman-runnable tests in any languages - this possibility is created by running tests in child processes.
							Writing tests in the form of shell scripts is something that almost every project could benefit from and now you can run these
						tests through your universal test runner - Suman!</li>
						<li>Composability - Suman tests should be able to run suman tests as child processes, ad inifitem, without hiccups.</li>
					</ul>
					<h1 id="-9658-test-framework-comparison">&#9658; Test Framework Comparison</h1>
					<h2 id="the-table-of-goodness">The Table of Goodness</h2>
					<table>
						<thead>
							<tr>
								<th></th>
								<th>Node-able</th>
								<th>Supports ES6/ES7  features</th>
								<th>Supports test isolation using  multiple Node.js processes</th>
								<th>Concurrency within suites</th>
								<th>Dependency Injection</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Mocha</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
							</tr>
							<tr>
								<td>Jasmine</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
							</tr>
							<tr>
								<td>Tape</td>
								<td>Yes</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
								<td>No</td>
							</tr>
							<tr>
								<td>AVA</td>
								<td>No, requires transpilation first</td>
								<td>Yes</td>
								<td>Yes</td>
								<td>Yes</td>
								<td>No</td>
							</tr>
							<tr>
								<td>Suman</td>
								<td>Yep, you can run any given test suite with the plain old node executable</td>
								<td>Yep, Suman will support all features</td>
								<td>Yep</td>
								<td>Yep</td>
								<td>Yep</td>
							</tr>
						</tbody>
					</table>
					<h2 id="le-matrix-of-madness">Le Matrix of Madness</h2>
					<table>
						<thead>
							<tr>
								<th></th>
								<th>Implicit globals</th>
								<th>Forces you to use their assertion library madness</th>
								<th>Confusing JS contexts madness</th>
								<th>Developer debugging / console.log output mixed with test output madness</th>
								<th>no concurrency madness</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Mocha</td>
								<td>Yes</td>
								<td>No</td>
								<td>Yes</td>
								<td>Yes</td>
								<td>Yes</td>
							</tr>
							<tr>
								<td>Jasmine</td>
								<td>Yes</td>
								<td>No</td>
								<td>Yes</td>
								<td>Yes</td>
								<td>Yes</td>
							</tr>
							<tr>
								<td>Tape</td>
								<td>No</td>
								<td>Yes</td>
								<td>No</td>
								<td>Yes</td>
								<td>Yes</td>
							</tr>
							<tr>
								<td>AVA</td>
								<td>No</td>
								<td>Yes</td>
								<td>No</td>
								<td>?</td>
								<td>No</td>
							</tr>
							<tr>
								<td>Suman</td>
								<td>Nope</td>
								<td>Nope, Suman is completely assertion-lib agnostic</td>
								<td>Nope, Suman greatly simplifies the context puzzle that Mocha provided</td>
								<td>Nope, Suman runner uses silent option with child_process so your output doesn&#39;t mix with the test results</td>
								<td>Nope</td>
							</tr>
						</tbody>
					</table>
					<h2 id="the-reasons-why-mocha-and-its-peers-need-a-replacement-are-clear-">The reasons why Mocha and its peers need a replacement are clear:</h2>
					<ul>
						<li>In Mocha, Tape and Jasmine test files were not run in separate processes (necessary for isolation, speed and independence of test results)</li>
						<li>Using Mocha, Tape and Jasmine, not only was everything run in a single process, but all test cases and hooks were also run in series, which takes unnecessary amounts of time for tests utilizing async I/O</li>
						<li>Mocha prescribed no solution to the problem of starting up the services necessary to do system/integration testing - using Mocha/Tape/AVA it is up to the developer to manually start those services,
						which makes automated testing much more difficult.</li>
						<li>Single process test runners like Mocha face out-of-memory issues - <a href="https://github.com/mochajs/mocha/issues/2555">https://github.com/mochajs/mocha/issues/2555</a>, these issues are
						much much less likely to occur if tests are split into multiple processes</li>
						<li>Mocha and Jasmine could not move forward with ES6/ES7 features due to certain software patterns used (globals and complex context binding)</li>
						<li>a BIG ONE: clean reporting - at the command line, using Mocha and Jasmine, logging/debugging output by the developer would obfuscate the test results, nullifying any advantage of reporting tools. Suman has a simple
						trick up its sleeve to allow for 100% clean reporting for any test or group of tests. </li>
						<li>Mocha and Jasmine could not have certain useful serverside features, because they were also constained by running in the browser.</li>
						<li>Mocha lacked real ability to do true dynamic testing (meaning, registering a dynamic number of it() test cases) =&gt; e.g., make a network call, get X values, create a test case for each.</li>
						<li>Mocha had confusing and obfuscated context values (values for &#39;this&#39;), which we have greatly simplified, allowing for the usage of arrow functions, etc </li>
						<li>Mocha, Jasmine and Tape lack some other nice features that are implemented by Suman. For example, Tape&#39;s ability to pre-load modules using the command line
						before running tests is nowhere near as powerful or easy to use as the dependency injection ability of this library.</li>
						<li>Using Mocha, Tape, Jasmine you could not easily pass data to tests, to reuse the same test code for different scenarios; Suman allows you to pass dynamic data
						to tests using dependency injection.</li>
						<li>cannot call tests programmatically without wrapping Mocha test suite in a function, Suman allows you to call tests programmiatcally, without having
						to wrap tests in a function.</li>
						<li>After writing a few Mocha tests, developers will find it&#39;s very difficult to properly run only one test - the &quot;only&quot; feature can help,
							but there are so many bugs that can crop up because of this, especially if you have some global hooks that need to run before your &quot;only&quot; test needs
						to run. Suman solves this problem ridiculously well, because Suman was designed to solve this very problem from the ground up. </li>
					</ul>
					<h2 id="suman-philosophy">Suman Philosophy</h2>
					<ul>
						<li>&quot;Just works&quot; - no need for addons or plugins, unless you want to write a custom reporter</li>
						<li>Fail-fast</li>
						<li>Stick to Node core modules</li>
						<li>Unlike AVA, you don&#39;t need to transpile with Babel if you don&#39;t want to: <em>as ES6 generators + Promises
						can give you the same coding patterns as ES7 async/await</em></li>
						<li>Provide a full-featured, non-dumbed-down API that&#39;s easy to get started with, and
						both powerful and intuitive to use over the long-run.</li>
						<li>Listen to what the community wants.</li>
						<li>Leverage Javascript&#39;s strengths (ahem <em>closures</em>)</li>
						<li>Don&#39;t be lazy.</li>
						<li>As Suman is a command line application, we can utilize a more functional programming style</li>
						<li>Details matter, and developer experience matters most.</li>
					</ul>
					<h1 id="-9658-suman-features-in-detail-">&#9658; Suman features in detail:</h1>
					<ul>
						<li><b> basics </b><ul>
								<li>=&gt; tdd/bdd interfaces </li>
								<li>=&gt; easy migration from Mocha (it&#39;s automated using the --convert option)</li>
								<li>=&gt; extremely powerful features, while aiming to be straightforward, clean, concise, consistent and accurate; </li>
								<li>=&gt; designed with ES6 and ES7 in mind, including Promises, generators and async/await </li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Improved mechanics, syntax and semantics </b><ul>
								<li>singular param (t) is used for all hooks and test cases, in the style of AVA</li>
								<li>Pass data from test cases directly to hooks using the t.value option of a test case</li>
								<li>Pass data from hooks directly to test cases using the t.data value
								(neither are possible with Mocha, and are very much a missing feature)</li>
								<li>encapsulation and immutability are utilized much more effectively than with Mocha etc</li>
								<li>instead of a &quot;grep&quot; option like Mocha&#39;s, we have &quot;match&quot; because we are filtering input not output!</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Full-blown concurrency</b><ul>
								<li>your tests will run much faster, especially if they are doing lots of network I/O</li>
								<li>test files are run in separate Node.js processes for speed, isolation and independence</li>
								<li>test cases and hooks in any given suite can be run concurrently, when using asynchronous I/O,
								using the &quot;parallel&quot; option in your code</li>
								<li>capability to control maximum number of processes running at a time (cap it at 6 processes, or 18 processes or whatever)</li>
								<li>capability to add constaints to prevent any given pair of tests from running at the same time, (if two different tests access the same
								external resource for example, and you don&#39;t want the interaction to cause false negatives).</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><p><b> Improved reporting </b></p>
							<ul>
								<li>using the Suman test runner, you can prevent any logging output from mixing with test reports, by redirecting stdout from the child process(es).</li>
								<li>Future effort: Suman includes a built-in web reporter that you can use to share test results with your team, using the Suman server</li>
								<li>Future effort: Suman server provides ability to store past test results (backdata) and view test results chronologically with browser to look at trends</li>
								<li>Future effort: testing backdata is stored in a local SQLite database
								which will allow you to run real queries on your test results, and share results with your team.)</li>
							</ul>
						</li>
						<li><p><b> Automatic test execution and/or test transpilation </b></p>
							<ul>
								<li>Using <code>suman --watch</code> you can execute test files or transpile test files as you write them</li>
								<li>Suman watcher processes run your tests and pipe stdout/stderr to log files which you tail with a terminal or browser window</li>
								<li>Running tests on the fly is a major portion of the optimal Suman workflow, and makes it all the more fun.</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Dynamicism </b><ul>
								<li>If there&#39;s anything you want to do with a test runner, you can do it with Suman</li>
								<li>Test files themselves allow for all sorts of dynamic behavior, dynamic and asynchronous test case generation, etc</li>
								<li>You can call tests programmatically and use them as macros</li>
								<li>Suman tests can create child processes which call Suman tests, etc etc.</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Use suman.once.js to run hooks before the test runner starts </b><ul>
								<li>these hooks can be used to start the services necessary for any given test file to run successfully; they only run once no matter how many tests are run, are only run
								if tests declare so. They offer a lighter weight option than containers for starting up the necessary servers in your backend system.</li>
								<li>Your suman.once.js file can augment the behavior of container build scripts etc, to help start up services necessary for testing to commence</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Very simple but powerful dependency injection (DI/IoC)</b><ul>
								<li>Inject dependencies sourced synchronously or asynchronously</li>
								<li>Most useful for injecting values acquired <em>asynchronously</em>, such as successful network connections and database values</li>
								<li>Inspired by familiar tools such as Angular and RequireJS</li>
								<li>Inject any core/&quot;built-in&quot; Node.js module by name, with zero configuration</li>
								<li>DI is used throughout the library, and relieves the burden on the developer to remember order of parameters</li>
								<li>Inject network values, test dependencies and library dependencies</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Test runner tuning </b><ul>
								<li>Add contraints to prevent any given pair of tests from running at the same time</li>
								<li>Cap the total number of processes running at the same time</li>
								<li>Suman &#39;once&#39; feature gives the developer the option to run checks to see if all necessary network components are live before running any given test</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Easy migration from Mocha </b><ul>
								<li>Suman includes a command line option to convert whole directories or individual Mocha tests to Suman tests</li>
								<li>before/after/beforeEach/afterEach hooks behave just like in Mocha</li>
								<li>solid command line tools and better grep facilities than predecessors</li>
								<li>skip/only also work like Mocha</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><b> Optional but first-rate transpilation features </b><ul>
								<li>Suman support for tranpilation is first-rate</li>
								<li>Suman allows you to use &quot;babel-register&quot; to transpile your sources on the fly or transpile a src directory to a target directory</li>
								<li>If you have less than ~20 tests, the recommended way to incorporate Babel in your testing is to simply transpile your entire &quot;test&quot; directory to &quot;test-target&quot;</li>
								<li>Using a &quot;test-target&quot; directory instead of &quot;babel-register&quot; allows for better debugging, performance and transparency in your testing system</li>
								<li>If you have more than 20 tests, Suman does not recommend transpilation, due to the performance penalty.</li>
								<li>For enterprise usage, we don&#39;t expect many teams to use transpilation features anyway; it&#39;s more likely individual developers who may
								wish to use Babel to transpile tests for a library.</li>
							</ul>
						</li>
					</ul>
					<ul>
						<li><p><b> Log files help you debug </b></p>
							<ul>
								<li>Using Suman tests, you have 3 options as to how you execute a test file: <code>1. node x.js, 2. suman x.js and 3. suman --runner x.js</code></li>
								<li>Using the Suman runner, your test file(s) all run in child processes. This can make debugging harder, but Suman sends all stderr from the child processes
								to a single log file to help you debug.</li>
								<li>Normally, to debug a test, you would run the test with node or using suman without using the runner, but if you see a problem with a particular test that only
								occurs when using the runner, then the log files will help.</li>
							</ul>
						</li>
						<li><p><b> Freedom: Suman is not highly opinionated, but gives you powerful features</b></p>
							<ul>
								<li>Suman prefers the standard core assert Node module (Suman has unopinionated assertions), but like Mocha you can use any assertion lib that throws errors</li>
								<li>Callbacks, promises, async/await, generators and event-emitters/streams are supported in any test case or hook.</li>
							</ul>
						</li>
					</ul>
					<h2 id="suman-design">Suman design</h2>
					<ul>
						<li>no implicit globals in test suite files, which were avoided due to the problems they caused for Jasmine and Mocha.</li>
						<li>Suman uses domains to isolate errors in asynchronous tests and hooks, and currently this is the only solution to this problem at the moment.
							Lab, the test runner for Hapi servers, also uses domains for this same purpose, and using domains allows for much better coding patterns (avoiding globals in
							the suman library.) Domains are facing deprecation, and Suman will replace domains with whichever suitable replacement is chosen by the Node.js core team,
							although after talking with many people near to core, domains will be supported for quite some time. As it stands, <em>Suman is a perfect use case for domains,
							as untrapped errors are supposed to be thrown in test code</em> (assertions, etc), and the developer experience in this library will be better than any other test library because of the use of domains, as they basically
						guarantee that we can pin an error to a particular test case or hook, no matter where the error originated from.</li>
					</ul>
					<h2 id="details-matter">Details matter</h2>
					<pre><code>* we designed Suman <span class="hljs-keyword">with</span> details <span class="hljs-keyword">in</span> mind
* fewer logical branches <span class="hljs-keyword">and</span> contingencies than Mocha WRT rules <span class="hljs-keyword">for</span> hooks
* much better semantics, <span class="hljs-keyword">with</span> <span class="hljs-keyword">new</span> standard functions alongside Mocha<span class="hljs-symbol">'s</span> <span class="hljs-symbol">'done</span>' callback: <span class="hljs-symbol">'ctn</span>', <span class="hljs-symbol">'pass</span>', <span class="hljs-symbol">'fail</span>' <span class="hljs-keyword">and</span> <span class="hljs-symbol">'fatal</span>' are <span class="hljs-keyword">new</span> functions
each <span class="hljs-keyword">with</span> a unique purpose <span class="hljs-keyword">and</span> meaning, <span class="hljs-keyword">and</span> done <span class="hljs-keyword">is</span> still <span class="hljs-keyword">in</span> Suman<span class="hljs-symbol">'s</span> API <span class="hljs-keyword">with</span> the same meaning as Mocha!
* friendly <span class="hljs-literal">error</span> messages, that also get sent <span class="hljs-keyword">to</span> suman-stderr.log <span class="hljs-keyword">for</span> reference
* <span class="hljs-keyword">when</span> debugging, (the debug flag <span class="hljs-keyword">is</span> set) timeouts will automatically be set <span class="hljs-keyword">to</span> <span class="hljs-symbol">'infinity</span>'
</code></pre><h2 id="we-can-say-with-confidence-that-suman-is-the-most-powerful-test-framework-for-serverside-javascript-on-planet-earth">We can say with confidence that Suman is the most powerful test framework for serverside JavaScript on planet Earth</h2>
					<p> =&gt; as it gives the developer total control and access to a very large set of features, with the explicit goal of being bug-free first, full-featured second.</p>
					<h2 id="simple-usage-examples">Simple usage examples</h2>
					<h4 id="example-using-es6-es7-api-">example using ES6/ES7 API:</h4>
					<p><i> Suman is as simple as you want it to be; but it&#39;s also packed with features that you can use. </i></p>
					<pre><code class="lang-js">
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> suman <span class="hljs-keyword">from</span> <span class="hljs-string">'suman'</span>
<span class="hljs-keyword">const</span> Test = suman.init(<span class="hljs-built_in">module</span>)


Test.create(<span class="hljs-string">'ES6/ES7 API Example'</span>, (baz, assert, path, http, beforeEach, it) =&gt; {  

    <span class="hljs-comment">// we have injected some core modules by name (http, assert, path) </span>
    <span class="hljs-comment">// we have also injected a module from our own project, baz</span>


     beforeEach(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> {

       <span class="hljs-keyword">const</span> req = http.request({
          <span class="hljs-attr">hostname</span>: <span class="hljs-string">'example.com'</span>
        }, res =&gt; {

           <span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;

           res.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>)</span>{
                  data += $data;
           })

           res.on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                  t.data.foo = data;
                  t.done()
           })


        })

        req.on(<span class="hljs-string">'error'</span>, fatal)
        req.end()


     })


     it(<span class="hljs-string">'detects metal'</span>, t =&gt; {
         assert(t.moo = <span class="hljs-string">'kabab'</span>)             
     })


     it(<span class="hljs-string">'ES7 is not necessary because we can achieve the same thing with generators'</span>, <span class="hljs-keyword">async</span> t =&gt; {

        <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">await</span> baz.doSomethingAsync()  
        assert(path.resolve(val.foo) === <span class="hljs-string">'/bar'</span>)

     })

     it(<span class="hljs-string">'you dont need to transpile, because achieves the same as above'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">t</span>)</span>{

        <span class="hljs-keyword">const</span> val = <span class="hljs-keyword">yield</span> baz.doSomethingAsync()
        assert(path.resolve(val.foo) === <span class="hljs-string">'/bar'</span>)

     })

})
</code></pre>
					<h3 id="basic-es5-api-">basic ES5 API:</h3>
					<p><i> It is recommended to avoid adding the extra complexity of transpiling your tests from ES7</i>
					<i> So using ES5 with some sprinkles of ES6 is just fine :)</i></p>
					<pre><code class="lang-js">
<span class="hljs-keyword">const</span> suman = <span class="hljs-built_in">require</span>(<span class="hljs-string">'suman'</span>)
<span class="hljs-keyword">const</span> Test = suman.init(<span class="hljs-built_in">module</span>)  

Test.create(<span class="hljs-string">'ES5 API Example'</span>, {<span class="hljs-attr">mode</span>: <span class="hljs-string">'parallel'</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">delay, assert, fs</span>)</span>{

   <span class="hljs-comment">//we have declared the root suite to be parallel, so all direct children will run in parallel with each other</span>
   <span class="hljs-comment">//note that instead of using "this.describe" we can choose to inject the describe method</span>

   <span class="hljs-comment">//test cases will run in parallel with child block 2,3</span>
    <span class="hljs-keyword">this</span>.describe(<span class="hljs-string">'child block 1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{     

        <span class="hljs-keyword">this</span>.it(<span class="hljs-string">'red wine'</span>, t =&gt; {
             assert(<span class="hljs-literal">true</span>)
        })

        <span class="hljs-keyword">this</span>.it(<span class="hljs-string">'white wine'</span>, t =&gt; {
             assert(<span class="hljs-literal">true</span>)
        })

    })

    <span class="hljs-comment">//test cases will run in parallel with child block 1,3</span>
    <span class="hljs-keyword">this</span>.describe(<span class="hljs-string">'child block 2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    

        <span class="hljs-keyword">this</span>.it(<span class="hljs-string">'lager'</span>, t =&gt; {
             assert(<span class="hljs-literal">true</span>)
        })

        <span class="hljs-keyword">this</span>.it(<span class="hljs-string">'IPA'</span>, t =&gt; {
             assert(<span class="hljs-literal">true</span>)
        })

    })


    <span class="hljs-comment">//test cases will run in parallel with child block 1,2</span>
    <span class="hljs-keyword">this</span>.describe(<span class="hljs-string">'child block 3'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    


     <span class="hljs-comment">// child block 3 is not declared to be parallel, and</span>
     <span class="hljs-comment">// because series is the default, its direct children will run in series</span>


         <span class="hljs-comment">//test cases will run in series with child block b</span>
         <span class="hljs-keyword">this</span>.describe(<span class="hljs-string">'child block a'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    




         })

        <span class="hljs-comment">//test cases will run in series with child block a</span>
        <span class="hljs-keyword">this</span>.describe(<span class="hljs-string">'child block b'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    




         })

    })

})
</code></pre>
					<h3 id="more-suman-examples">More Suman Examples</h3>
					<ul>
						<li>See the documentation @ sumanjs.org</li>
						<li>You can also read: <a href="https://medium.com/@the1mills/introducing-suman-a-node-js-testing-library-20fdae524cd">https://medium.com/@the1mills/introducing-suman-a-node-js-testing-library-20fdae524cd</a></li>
					</ul>
					<h3 id="s-l-a-">S.L.A.</h3>
					<p>The Service Level Agreement is that Suman will constantly be up-to-date with the newest features available via the node executable.
						We will focus on what&#39;s in Node and not what&#39;s available in Babel or other transpilers. That being said, we will also work to ensure Babel features are also supported,
						but we will primarily focus on making Suman completely bug-free when it comes to the latest version of Node, not the latest abilities of Babel or the like.
						By the time any ES6/ES7/ES8 feature is available in Node, it will be supported by Suman. We want to emphasize the utility of the option of running things
					with the plain old Node executable, as opposed to adding the complexity of transpilation.</p>
					<h3 id="execution-modes-for-a-single-test-file">Execution modes for a single test file</h3>
					<p>You can execute a test file with the plain <code>node</code> executable, with <code>$ suman</code> and with <code>$ suman --runner</code></p>
					<p>Here are the differences between the 3 options:</p>
					<table>
						<thead>
							<tr>
								<th></th>
								<th>$ node a.test.js</th>
								<th>$ suman a.test.js</th>
								<th>$ suman --runner a.test.js</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>command line options</td>
								<td>no</td>
								<td>yes</td>
								<td>yes</td>
							</tr>
							<tr>
								<td>runs multiple processes</td>
								<td>no</td>
								<td>no</td>
								<td>yes</td>
							</tr>
							<tr>
								<td>suppress stdout/stderr</td>
								<td>no</td>
								<td>no</td>
								<td>yes</td>
							</tr>
							<tr>
								<td>easy to debug?</td>
								<td>easy</td>
								<td>medium</td>
								<td>hard</td>
							</tr>
						</tbody>
					</table>
					<p>In order to run multiple files, you must use <code>$ suman --runner</code>; the above table
					only pertains to running a single test file (usually when developing a particular test.)</p>
					<h3 id="faq">FAQ</h3>
					<ul>
						<li><p>Q: Why dependency injection in Node.js? Isn&#39;t it a waste of time?</p>
							<ul>
								<li>A: Normally it is. Dependency injection is very useful in the browser and is used by both Angular 1.x and RequireJS. In Node.js we usually have all our dependencies or we can easily load
									our dependencies synchronously on demand with the require function. However, with test suites, it was until now impossible to load dependencies and values <em>asynchronously</em> before registering test cases.
								DI allows you truly awesome and convenient ability to create and procure values asynchronously before any tests are run, and injecting the values in any test suite you wish.</li>
							</ul>
						</li>
						<li><p>Q: Can I use arrow functions? </p>
							<ul>
								<li>A: Yes you can use arrow functions everywhere; however to use them with test blocks, you cannot access
								methods using &#39;this&#39; - you must inject the methods. See: sumanjs.org/di</li>
							</ul>
						</li>
					</ul>
					<h2 id="important-aside-how-is-suman-better-than-ava-">Important aside - How is Suman better than AVA?</h2>
					<p> It should be abundantly clear why Suman is better than Mocha, but how is Suman better than AVA?
						(If it&#39;s not clear why Suman is better than Mocha then scroll back up).
						Suman borrows some excellent features from Mocha that AVA seems to ignore, including the ability
						to use nested describe blocks for more control and preventing the sharing of scope within tests. AVA basically
						co-opted Tape and added concurrency. Suman co-opted Mocha, added concurrency, better reporting, dependency injection and
						less confusing contexts for callbacks. Suman has more powerful facilities for asynchronous testing than AVA due to Mocha/Jasmine-style hooks
						and nested describes. Dependency injection also makes Suman extremely convenient and fun to use, compared to AVA.
					Suman is simply more powerful and richer in features than AVA. </p>
					<ul>
						<li><p>AVA test are not &quot;node-able&quot; - you <em>cannot</em> run them with node directly; Suman tests are node-able, which makes
								debugging so much easier and intuitive! Note that Suman does make is easy for developers to debug child processes.,
							giving them built-in tools to do so.</p>
							<p><img src="https://github.com/ORESoftware/suman-private/blob/dev/images/ava-prob.png" alt="alt text"></p>
						</li>
						<li><p>AVA requires Babel transpilation, which adds unnecessary complexity for test environments, and is also much slower</p>
						</li>
						<li>AVA does not handle errors thrown in asynchronous code gracefully, Suman is much better in this regard.</li>
						<li>AVA does not feature the nested describes of Mocha or Suman, which limits the expressiveness of the library
						tremendously!</li>
						<li>AVA expects you to use its assertion library, whereas Suman will accept usage of any assertion library that
						you are already familiar with.</li>
						<li><p>Furthermore, AVA does not prescribe solutions to common test problems -</p>
							<pre><code> * registering dynamic test cases (given <span class="hljs-keyword">a</span> dynamic <span class="hljs-built_in">value</span> acquired asynchronously)
 * starting up necessary services <span class="hljs-keyword">before</span> running tests
 * injecting different dependencies <span class="hljs-keyword">into</span> test <span class="hljs-built_in">files</span>
</code></pre></li>
					</ul>
					<p> Alternatively, with Suman:</p>
					<p> <em>Suman has nested describe blocks, which are imperative for non-trivial tests; a simple but common example is a before hook that you want
							to run only for a certain subset of tests in your test file. The before hook and tests would go in a nested describe block.
						</em>Babel transpilation is totally optional - you can achieve the async/await pattern with generators and promises alone, you don&#39;t need ES7 for this
						*Suman uses domains to correctly map runtime/assertion errors to test cases and hooks,
					which provides a much more reliable and well-designed piece of software because it can handle any error that gets thrown, not just assertion errors.</p>
					<h3 id="contributing-testing-and-pull-requests">Contributing - Testing and pull requests</h3>
					<p> (Please see contributing.md)</p>
					<p> Suman uses itself to test itself :) As it should.
					The right way to do this is as follows:</p>
					<pre><code> git clone https:<span class="hljs-comment">//github.com/sumanjs/suman.git &amp;&amp;</span>
 npm install <span class="hljs-meta">&amp;&amp;</span>
 npm link . <span class="hljs-meta">&amp;&amp;</span>
 npm link suman <span class="hljs-meta">&amp;&amp;</span>
 npm test
</code></pre><h3 id="extra-info">Extra info</h3>
					<p>If you are familiar with Mocha and enjoy both its power and simplicity, you may prefer Suman over AVA,
						and Suman provides the simplest migration path from Mocha. As was stated AVA draws more from Tape and Suman draws more from Mocha.
					Suman was designed to make the transition from Mocha to be as seamless as possible.</p>
					<p>** dependency arrays of strings exist so that during minification we can still know where to inject dependencies, that&#39;s why Angular and RequireJS have deps arrays of strings - they don&#39;t get
					corrupted by minification/uglification. But for backend testing frameworks, it is very unlikely we need to minify, so we don&#39;t need the dependency array.</p>
					<h2 id="looking">Looking</h2>
					<p> <br>
						<b>Looking for open source dev(s): </b>
						<br>
						Suman is currently looking for a full-stack web developer experienced with both Node.js and React to split the plaudits for this project,
						and who is interested in contributing to open source with the notion that it&#39;s very unlikely any monetary gains will be seen from it :)
						This project yearns for a really excellent web reporter UI and corresponding backend to support it,
						and what we have now is just the beginning when it comes to the web reporter.
						With some work it could prove to be indispensable for developers working with this lib. This project is very multifaceted and
					it will involve full-stack work with SQLite, Express and React. Relative newbs welcome. Thanks!</p>
					<p><br></p>
					<p><img src="https://raw.githubusercontent.com/sumanjs/suman-docs/master/images/suman.png" alt="alt text" title="Suman Primary Logo"></p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class="label tsd-is-external">
						<span>Internals</span>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_suman_constants_.html">"config/suman-<wbr>constants"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_acquire_deps_.html">"lib/acquire-<wbr>deps"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_acquire_deps_fill_in_.html">"lib/acquire-<wbr>deps-<wbr>fill-<wbr>in"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_acquire_deps_original_.html">"lib/acquire-<wbr>deps-<wbr>original"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_cli_commands_install_global_deps_.html">"lib/cli-<wbr>commands/install-<wbr>global-<wbr>deps"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_cli_commands_postinstall_.html">"lib/cli-<wbr>commands/postinstall"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_cli_commands_run_diagnostics_.html">"lib/cli-<wbr>commands/run-<wbr>diagnostics"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_create_opt_create_.html">"lib/create-<wbr>opt/create"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_exec_suite_.html">"lib/exec-<wbr>suite"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_freeze_existing_.html">"lib/freeze-<wbr>existing"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_handle_injections_.html">"lib/handle-<wbr>injections"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_async_gen_.html">"lib/helpers/async-<wbr>gen"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_convert_mocha_.html">"lib/helpers/convert-<wbr>mocha"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_determine_if_suman_is_installed_.html">"lib/helpers/determine-<wbr>if-<wbr>suman-<wbr>is-<wbr>installed"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_fatal_request_reply_.html">"lib/helpers/fatal-<wbr>request-<wbr>reply"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_get_istanbul_exec_path_.html">"lib/helpers/get-<wbr>istanbul-<wbr>exec-<wbr>path"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_handle_runner_request_response_.html">"lib/helpers/handle-<wbr>runner-<wbr>request-<wbr>response"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_handle_suman_once_post_.html">"lib/helpers/handle-<wbr>suman-<wbr>once-<wbr>post"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_implementation_error_.html">"lib/helpers/implementation-<wbr>error"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_job_queue_.html">"lib/helpers/job-<wbr>queue"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_load_reporters_.html">"lib/helpers/load-<wbr>reporters"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_load_shared_objects_.html">"lib/helpers/load-<wbr>shared-<wbr>objects"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_load_suman_config_.html">"lib/helpers/load-<wbr>suman-<wbr>config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_log_exit_.html">"lib/helpers/log-<wbr>exit"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_log_stdio_of_child_.html">"lib/helpers/log-<wbr>stdio-<wbr>of-<wbr>child"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_no_files_found_error_.html">"lib/helpers/no-<wbr>files-<wbr>found-<wbr>error"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_resolve_shared_dirs_.html">"lib/helpers/resolve-<wbr>shared-<wbr>dirs"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_run_after_always_.html">"lib/helpers/run-<wbr>after-<wbr>always"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_start_server_.html">"lib/helpers/start-<wbr>server"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_vet_paths_.html">"lib/helpers/vet-<wbr>paths"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_helpers_we_are_debugging_.html">"lib/helpers/we-<wbr>are-<wbr>debugging"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_index_.html">"lib/index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_make_test_suite_.html">"lib/make-<wbr>test-<wbr>suite"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_make_test_suite_base_.html">"lib/make-<wbr>test-<wbr>suite-<wbr>base"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_patches_all_ts_.html">"lib/patches/all-<wbr>ts"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_reporters_std_reporter_.html">"lib/reporters/std-<wbr>reporter"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_run_child_not_runner_.html">"lib/run-<wbr>child-<wbr>not-<wbr>runner"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_runner_.html">"lib/runner"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_runner_helpers_handle_multiple_processes_.html">"lib/runner-<wbr>helpers/handle-<wbr>multiple-<wbr>processes"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_runner_helpers_make_handle_blocking_.html">"lib/runner-<wbr>helpers/make-<wbr>handle-<wbr>blocking"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_runner_helpers_runner_utils_.html">"lib/runner-<wbr>helpers/runner-<wbr>utils"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_suman_.html">"lib/suman"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_t_proto_.html">"lib/t-<wbr>proto"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_t_proto_hook_.html">"lib/t-<wbr>proto-<wbr>hook"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_get_all_eaches_.html">"lib/test-<wbr>suite-<wbr>helpers/get-<wbr>all-<wbr>eaches"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_handle_callback_helper_.html">"lib/test-<wbr>suite-<wbr>helpers/handle-<wbr>callback-<wbr>helper"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_handle_promise_generator_.html">"lib/test-<wbr>suite-<wbr>helpers/handle-<wbr>promise-<wbr>generator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_handle_test_result_.html">"lib/test-<wbr>suite-<wbr>helpers/handle-<wbr>test-<wbr>result"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_make_handle_befores_afters_.html">"lib/test-<wbr>suite-<wbr>helpers/make-<wbr>handle-<wbr>befores-<wbr>afters"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_make_handle_each_.html">"lib/test-<wbr>suite-<wbr>helpers/make-<wbr>handle-<wbr>each"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_make_handle_test_.html">"lib/test-<wbr>suite-<wbr>helpers/make-<wbr>handle-<wbr>test"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_make_start_suite_.html">"lib/test-<wbr>suite-<wbr>helpers/make-<wbr>start-<wbr>suite"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_make_the_trap_.html">"lib/test-<wbr>suite-<wbr>helpers/make-<wbr>the-<wbr>trap"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_helpers_notify_parent_that_child_is_complete_.html">"lib/test-<wbr>suite-<wbr>helpers/notify-<wbr>parent-<wbr>that-<wbr>child-<wbr>is-<wbr>complete"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_after_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>after"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_after_each_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>after-<wbr>each"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_before_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>before"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_before_each_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>before-<wbr>each"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_describe_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>describe"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_inject_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>inject"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lib_test_suite_methods_make_it_.html">"lib/test-<wbr>suite-<wbr>methods/make-<wbr>it"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_test_src_es5_es6_b_.html">"test/src/es5-<wbr>es6/b"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_test_src_typescript_a_test_.html">"test/src/typescript/a.test"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_test_src_typescript_b_test_.html">"test/src/typescript/b.test"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_test_target_es5_es6_b_.html">"test/target/es5-<wbr>es6/b"</a>
					</li>
					<li class="label tsd-is-external">
						<span>Externals</span>
					</li>
					<li class=" tsd-kind-external-module tsd-is-external">
						<a href="modules/_node_modules_suman_utils_lib_run_transpile_.html">"node_<wbr>modules/suman-<wbr>utils/lib/run-<wbr>transpile"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>